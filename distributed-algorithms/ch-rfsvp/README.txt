General Information
===================
This package contains source code for the application(s) that implements the
Replicated File System with Voting Protocol to maintain consistency.

The source code is POSIX compliant and uses the standard C99 data types.

The source code builds two separate applications:
   1. The manager node which talks to all the servers of the replicated file 
      system by sending commands and receiving responses to the commands. This
      application is named "ch-rfsvp-mgr".
   2. The server program which participate in the Voting Protocol to maintain
      consistency of the Replicated File System which it is part of. This 
      application is named "ch-rfsvp-server".

Building The Sourcecode
=======================
1. % git clone https://github.com/corehacker/projects.git
2. Navigate to distributed-algorithms/ch-rfsvp.
   % cd distributed-algorithms/ch-rfsvp
3. Issue make command after issuing make clean.
   % ./configure
   % make clean
   % make
   After successful execution of the above commands, the executables "ch-rfsvp-mgr"
   and "ch-rfsvp-server" will be created in the current directory.
4. Copy the aplication to the desired directoty.
   % cp ch-rfsvp-mgr ch-rfsvp-server <Desired Directory>
   
Execution
=========
1. Requirements:
   a. Current implementation supports execution of algorithm for arbitrary  
      number of server nodes. But there is a cap put up so that total number of 
      server nodes does not exceed 50. Although, changing a few macros will 
      enable the application to support more server nodes.
   b. All the nodes should reachable by each other and all firewall for incoming
      connections for the ports that will be used (refer below) should be
      disabled.
   c. The server application accepts only DNS host name of the manager.

2. Application Usage:
   a. ch-rfsvp-mgr
      Usage: 
      $ ./ch-rfsvp-mgr <Total Server Nodes> <Listen Port Range Start> 
         <Command Filename/Path> <Console Logging> 
         [<Port No For Internal Use>]

      Parameter Details: 
         <Total Server Nodes, Range: 2 - 10> - Mandatory
         <Listen Port Range Start (> 15000 Preferred)> - Mandatory
         <Command filename/path (512 characters)> - Mandatory
         <Console Logging, 1 - Enable, 0 - Disable> - Mandatory
         [<Port No For Internal Use (Defaults to 19000)>] - Optional. But
            required if bind fails for the internal port

   b. ch-rfsvp-server
      Usage:
      $ ./ch-rfsvp-server <Total Server Nodes> <Node Index> 
         <Listen Port Range Start> <Manager Host Name> <Manager Port Number> 
         <Console Logging> [<Port No For Internal Use>]

      Parameter Details: 
         <Total Server Nodes, Range: 2 - 10> - Mandatory
         <Node Index, Range: 0 - 9; 0th index will mapped to leader.> - 
            Mandatory
         <Listen Port Range Start (> 15000 Preferred)> - Mandatory
         <Manager Host Name> - Mandatory
         <Manager Port Number> - Mandatory
         <Console Logging, 1 - Enable, 0 - Disable> - Mandatory
         [<Port No For Internal Use (Defaults to 19000)>] - Optional. But 
            required if bind fails for the internal port

3. Example:
   a. Catch hold of 8 machines named machine1-machine18. (8 nodes)
   b. Navigate to the directory where the ch-rfsvp-mgr, ch-rfsvp-server executables are
      located.
   c. Starting from machine1, execute the following commands, one on
      each node, in sequence. (This sequence is not necessary, but to make the
      executions simpler.). Here machine1 will be used as the manager
      node.
      % ./ch-rfsvp-mgr 5 37000 commands.txt 1
      % ./ch-rfsvp-server 7 0 37001 machine1 37000 1
      % ./ch-rfsvp-server 7 1 37001 machine1 37000 1
      % ./ch-rfsvp-server 7 2 37001 machine1 37000 1
      % ./ch-rfsvp-server 7 3 37001 machine1 37000 1
      % ./ch-rfsvp-server 7 4 37001 machine1 37000 1
      % ./ch-rfsvp-server 7 5 37001 machine1 37000 1
      % ./ch-rfsvp-server 7 6 37001 machine1 37000 1
	  
	  A sample commands file is available in the package.

   d. Wait till all server nodes join the computation. Then depending on the
      commands in the commands.txt follow the prompt in the terminal where
      the manager is running.
   e. In case of any node going down (crash/network failure) please restart the
      applications as described in c above.
   f. For each and every run, make sure that the file generated by the server
      node, ch-rfsvp-server_data_<Node Index>_<Server DNS Hostname>.txt is
      removed. This will ensure easy verification of the commits.

4. Data Verification
   a. Each server node writes a file as follows:
      ch-rfsvp-server_data_<Node Index>_<Server DNS Hostname>.txt
   b. The server data files may be same or different. This depends on the
      command file and the sequence of WRITES and READS performed on the files.

5. Miscellaneous
   a. The program has been check for memory leaks and found to be none in the
      "happy path" case, i.e., when the algorithm executes and finishes till
      the end.

Known Issues
============
1. If the timeouts in the command file is too less, then the server code does 
   not handle the cases of deadlock. The computation has to be restarted.

Copyright
=========
Copyright Sandeep Prakash (c), 2012
Sandeep Prakash - 123sandy@gmail.com

References
==========
[1] Jajodia, S.; Mutchler, D., “A hybrid replica control algorithm combining 
    static and dynamic voting,” Knowledge and Data Engineering, IEEE 
    Transactions on , vol.1, no.4, pp.459-469, Dec 1989.

[2] O.S.F. Carvalho and G. Roucairol. On Mutual Exclusion in Computer Networks 
    (Technical Correspondence). Communications of the ACM, February 1983.

[3] G. Ricart and A. K. Agrawala. An Optimal Algorithm for Mutual Exclusion in
    Computer Networks. Communications of the ACM, 24(1):9{17, January 1981.